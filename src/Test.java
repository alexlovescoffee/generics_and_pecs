import java.util.ArrayList;
import java.util.List;

/*
     Принцип PECS -> Producer EXTENDS Consumer SUPER, или по другому:
     - Если нужно получить элемент то используем <? extends T> - неизвестный тип наследующий от T
     - Если нужно добавить элемент то используем <? super T> - неизвестный тип предок T

     Ковариантность — сохранение иерархии наследования исходных типов в производных типах в том же порядке.
     Контрвариантность — обращение иерархии исходных типов на противоположную в производных типах.
     Инвариантность — отсутствие наследования между производными типами.

     Массивы коварианты: Object[] obj = new String[];
     Дженерики инварианты: List<Object> ≠ List<String>
     Дженерики коварианты: List<? extends Object> = List<String>
     Дженерики контрвариантны: List<? super String> = List<Object>
*/

public class Test {
    public void producerConsumes(List<? extends B> list1) {
        /*
        Почему нельзя добавлять элементы? Неизвестно что именно может храниться в списке, кроме того, что это должен
        быть наследник класса B или null. Например, имеем: */
        List<C> list2 = new ArrayList<>();
        list1 = list2;
        /*
        Или, по другому: list1<? extends B> = list2<C>, класс С является потомком класса B, такое присваивание разрешено
        Теперь попытаемся выполнить следующее: */
        list1.add(new A());
        list1.add(new B());
        list1.add(new C());
        list1.add(new Object());
        list1.add(null);
        /*
        Мы условились хранить в списке объекты класса C, если бы добавление было разрешено, можно было бы сохранить в
        список например класс B, который не является классом С (несмотря на то, что С его потомок). Преобразование от
        родителя к потомку: */
        new ArrayList<C>().add((C) new B()); /* вызовет ошибку ----> ClassCastException*/
    }

    public void producerProduces(List<? extends B> list1) {
        /*
        Почему можно получать элементы? Мы точно знаем, что list1 может хранить объекты-наследники класса B,
        соответственно мы всегда можем присвоить переменной типа B любой элемент из списка, т.к. B будет являться его
        предком: */
        B b = list1.get(0);
        A a = list1.get(0); /*A суперкласс для B и может ссылаться на элемент списка*/
        Object o = list1.get(0); /*Object суперкласс для A и может ссылаться на элемент списка*/
    }

    public void consumerConsumes(List<? super B> list1) {
        /*
        Почему можно добавлять элементы и как работает логика добавления? Нам неизвестно что будет храниться в списке,
        кроме того, что это может быть класс B или его суперклассы. Но, так как мы знаем, что в списке будет храниться
        иерархия класса B, то мы можем добавлять в список любых потомков класса B, это равносильно B b = new C();
        */
        list1.add(new A());
        list1.add(new B());
        list1.add(new C());
        list1.add(new Object());
        list1.add(null);
        /*
        Почему же нельзя добавлять предков класса B? Рассмотрим пример: */
        List<A> list2 = new ArrayList<>();
        list1 = list2;
        /*
        Или по другому: list1<? super B> = list2<A>, класс A является суперклассом B, такое присваивание разрешено.
        Теперь попытаемся добавить элементы: */
        list1.add(new Object());
        list1.add(new A());
        /*
        Если бы пример скомпилировался, мы бы без проблем добавили в список new A(), т.к. он типизирован как List<A>. Но
        мы бы не смогли положить туда new Object(), который не является классом A (хоть и является его родителем).
        Преобразование от родителя к потомку: */
        new ArrayList<A>().add((A) new Object()); /* вызовет ошибку ----> ClassCastException*/
    }

    public void consumerProduces(List<? super B> list1) {
        /*
        Почему нельзя получать элементы? Мы не знаем что хранится в списке, кроме того что это класс B либо его
        суперкласс. Переменная типа Object удовлетворяет этим условиям, поэтому в нее можно получить элемент: */
        Object obj = list1.get(0);
        /*
        В производные классы от B получить элемент уже не получится: */
        C c = list1.get(0);
        /*
        Но никакие другие суперклассы B не удовлетворяют условиям ситуации, при которой элемент, получаемый из списка,
        является предком по отношению к переменной в которую он будет записан: */
        List<A> list2 = new ArrayList<>();
        list1 = list2;
        B b = list1.get(0);
        /*
        Такое присваивание равнозначно String str = new Object() и поэтому запрещено.
        Если бы мы знали, каким классом параметризован список, то можно было бы написать так: */
        B b1 = (B) list1.get(0);
        /*
        К сожалению, на стадии RunTime, информация о типе стирается, и у нас нет возможности узнать, каким именно
        классом параметризовали список. Поэтому компилятор, чтобы избежать неоднозначности, запрещает небезопасные
        присваивания. */
    }

    static class A{}
    static class B extends A{}
    static class C extends B{}
    static class D extends C{}
}
